#  Notes

[第00讲   开篇词：实战是学习新技术的不二法门.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453021/00.md)
[第01讲：什么是微服务架构.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453022/01.md)
[第02讲：什么是 Docker 与容器化技术.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453023/02.Docker.md)
[第03讲：云原生应用的 15 个特征.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453024/03.15.md)
[第04讲：什么是 Kubernete 容器化应用.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453025/04.Kubernete.md)
[第05讲：什么是服务网格（Service Meh）.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453026/05.Service.Meh.md)
[第06讲：示例应用介绍与用户场景分析.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453027/06.md)
[第07讲：如何进行领域驱动设计.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453028/07.md)
[第08讲：如何对示例应用进行微服务划分.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453029/08.md)
[第09讲：快速部署开发环境与框架.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453030/09.md)
[第10讲：使用 OpenAPI 和 Swagger 实现 API 优先设计.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453031/10.OpenAPI.Swagger.API.md)
[第11讲：使用 Spring Data JPA 实现数据库驱动微服务.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453032/11.Spring.Data.JPA.md)
[第12讲：如何基于 JUnit 5 的服务实现单元测试.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453033/12.JUnit.5.md)
[第13讲：如何基于 REST 服务实现集成测试.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453034/13.REST.md)
[第14讲：事件如何驱动微服务设计与异步消息传递.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453035/14.md)
[第15讲：什么是事务性消息模式.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453036/15.md)
[第16讲：事件发布如何进行处理.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453037/16.md)
[第17讲：如何设计与实现事件源（Event ourcing）.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453038/17.Event.ourcing.md)
[第18讲：如何处理司机位置更新事件.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453040/18.md)
[第19讲：如何实现行程派发与调度算法.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453041/19.md)
[第20讲：什么是数据一致性与 Saga 模式.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453042/20.Saga.md)
[第21讲：如何使用 Saga 模式实现行程验证.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453043/21.Saga.md)
[第22讲：CQRS 如何设计与实现.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453044/22.CQRS.md)
[第23讲：如何查询乘客和司机的行程.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453045/23.md)
[第24讲：服务调用失败的处理策略与实践.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453046/24.md)
[第25讲：如何基于 Spring Security 和 JWT 实现访问控制.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453047/25.Spring.Security.JWT.md)
[第26讲：服务版本更新策略是什么.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453048/26.md)
[第27讲：如何实现应用配置的外部化与管理.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453049/27.md)
[第28讲：使用 Prometheu 和 Grafana 处理性能指标数据.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453050/28.Prometheu.Grafana.md)
[第29讲：使用 Fluentd、ElaticSearch 和 Kibana 管理日志.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453051/29.Fluentd.ElaticSearch.Kibana.md)
[第30讲：使用 Sentry 处理异常.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453052/30.Sentry.md)
[第31讲：如何设计与实现 API 组合.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453053/31.API.md)
[第32讲：如何使用 Netflix Falcor 组合 API.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453054/32.Netflix.Falcor.API.md)
[第33讲：如何使用 GraphQL 组合 API.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453055/33.GraphQL.API.md)
[第34讲：如何安装与配置 Itio.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453056/34.Itio.md)
[第35讲：使用 API 网关作为应用请求入口.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453057/35.API.md)
[第36讲：什么是服务重试与熔断器.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453058/36.md)
[第37讲：如何实现追踪服务性能指标.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453059/37.md)
[第38讲：如何实现服务访问控制与双向 TLS.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453060/38.TLS.md)
[第39讲：使用 Jenkin 进行持续集成.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453061/39.Jenkin.md)
[第40讲：如何持续部署到阿里云.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453062/40.md)
[第41讲：如何结合服务网格进行灰度发布.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453063/41.md)
[第42讲：使用 Spring HATEOAS 增强 REST 服务的语义.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453065/42.Spring.HATEOAS.REST.md)
[第43讲：使用 gRPC 作为服务之间的交互方式.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453066/43.gRPC.md)
[第44讲：使用 Quarku 开发微服务.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453067/44.Quarku.md)
[第45讲：消费者驱动的服务契约测试.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453068/45.md)
[第50讲    结束语：微服务架构展望.md](https://github.com/latermonk/Cloud-Native-Microservice-Arch/files/7453069/50.md)
